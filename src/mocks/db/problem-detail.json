{
  "problem_details": [
    {
      "id": "two-sum-detail",
      "problem_id": 1,
      "slug": "two-sum",
      "summary": "You are given an integer array `nums` and an integer `target`. Your goal is to **return the indices** of the *two numbers* such that they add up to the target value.\n\nEvery input has *exactly one solution*, and you may **not** reuse the same element twice.\n\n### Key Insight\n- Scan the array while storing previously seen values in a hash map.\n- For each index (i), check whether there exists a complement (target - nums_i).\n\nThe relationship can be written as:\n\n$\nnums[i] + nums[j] = target\n$\n\nReturn ([i, j])) in any order once a valid pair is found.",
      "companies": ["Amazon", "Google", "Microsoft", "Meta"],
      "likes": 49421,
      "dislikes": 1600,
      "difficulty_rating": 1197,
      "updated_at": "2025-11-01T00:00:00.000Z",
      "follow_up": "Can you design an algorithm that solves the two sum problem if the input array is sorted? What if we need to return the actual pairs instead of indices?",
      "constraints_json": [
        "$2 \\leq |nums| \\leq 10^4$",
        "$-10^9 \\leq nums[i] \\leq 10^9$",
        "$-10^9 \\leq target \\leq 10^9$",
        "Exactly one valid pair exists for each test case."
      ]
    }
  ],
  "problem_examples": [
    {
      "id": "example-1",
      "problem_id": 1,
      "example_order": 0,
      "input_text": "**Input:** `nums = [2,7,11,15]`, `target = 9`",
      "output_text": "**Output:** `[0,1]`",
      "explanation": "Indices satisfy $nums_0 + nums_1 = 7 + 2 = 9$. Return `[0, 1]` in ascending order."
    },
    {
      "id": "example-2",
      "problem_id": 1,
      "example_order": 1,
      "input_text": "**Input:** `nums = [3,2,4]`, `target = 6`",
      "output_text": "**Output:** `[1,2]`",
      "explanation": "Complement lookup: $target - nums_2 = 6 - 4 = 2$, which already exists at index 1."
    },
    {
      "id": "example-3",
      "problem_id": 1,
      "example_order": 2,
      "input_text": "**Input:** `nums = [3,3]`, `target = 6`",
      "output_text": "**Output:** `[0,1]`",
      "explanation": "Both entries are equal so the first complement is found immediately: $3 + 3 = 6$."
    }
  ],
  "problem_approaches": [
    {
      "id": "hash-map",
      "problem_id": 1,
      "title": "Hash map one-pass",
      "summary": "Traverse the array once while tracking complements inside a hash map. If the complement exists we have found the answer; otherwise store the current value and continue.",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "code_snippet": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen; // value -> index\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return { seen[complement], i };\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};",
      "language": "C++"
    },
    {
      "id": "brute-force",
      "problem_id": 1,
      "title": "Brute force pairs",
      "summary": "Check each pair of numbers until a matching pair is found. This approach is easy to reason about but quadratic in time.",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "code_snippet": "var twoSum = function(nums, target) {\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums[i] + nums[j] === target) {\n        return [i, j]\n      }\n    }\n  }\n  return []\n}",
      "language": "JavaScript"
    }
  ],
  "problem_approach_steps": [
    {
      "id": "hash-map-step-1",
      "approach_id": "hash-map",
      "step_order": 0,
      "content": "Initialize an empty hash map mapping value → index."
    },
    {
      "id": "hash-map-step-2",
      "approach_id": "hash-map",
      "step_order": 1,
      "content": "For each index i, compute complement = target - nums[i]."
    },
    {
      "id": "hash-map-step-3",
      "approach_id": "hash-map",
      "step_order": 2,
      "content": "If complement exists in the map, return the stored index with i."
    },
    {
      "id": "hash-map-step-4",
      "approach_id": "hash-map",
      "step_order": 3,
      "content": "Otherwise store nums[i] with index i and continue scanning."
    },
    {
      "id": "brute-force-step-1",
      "approach_id": "brute-force",
      "step_order": 0,
      "content": "Use two nested loops to inspect all unique pairs."
    },
    {
      "id": "brute-force-step-2",
      "approach_id": "brute-force",
      "step_order": 1,
      "content": "Return as soon as nums[i] + nums[j] equals target."
    },
    {
      "id": "brute-force-step-3",
      "approach_id": "brute-force",
      "step_order": 2,
      "content": "Otherwise continue until the array is exhausted."
    }
  ],
  "problem_languages": [
    {
      "id": "ts",
      "problem_id": 1,
      "label": "TypeScript",
      "value": "typescript",
      "starter_code": "function twoSum(nums: number[], target: number): number[] {\n  const seen = new Map<number, number>()\n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i]\n    if (seen.has(complement)) {\n      return [seen.get(complement)!, i]\n    }\n    seen.set(nums[i], i)\n  }\n  return []\n}"
    },
    {
      "id": "py",
      "problem_id": 1,
      "label": "Python 3",
      "value": "python",
      "starter_code": "from typing import List\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
    },
    {
      "id": "cpp",
      "problem_id": 1,
      "label": "C++",
      "value": "cpp",
      "starter_code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen; // value -> index\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return { seen[complement], i };\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
    }
  ],
  "problem_starter_notes": [
    {
      "id": "two-sum-note-1",
      "problem_id": 1,
      "content": "Use a hash map to store previous values and their indices."
    },
    {
      "id": "two-sum-note-2",
      "problem_id": 1,
      "content": "Stop as soon as you find a matching complement."
    },
    {
      "id": "two-sum-note-3",
      "problem_id": 1,
      "content": "Return indices, not the values themselves."
    }
  ],
  "problem_recent_results": [
    {
      "id": "res-1",
      "problem_id": 1,
      "case_label": "Case 1",
      "status": "Accepted",
      "runtime": "2 ms",
      "memory": "43.1 MB",
      "detail": "Output matched expected value."
    },
    {
      "id": "res-2",
      "problem_id": 1,
      "case_label": "Case 2",
      "status": "Accepted",
      "runtime": "2 ms",
      "memory": "42.8 MB",
      "detail": "Output matched expected value."
    },
    {
      "id": "res-3",
      "problem_id": 1,
      "case_label": "Case 3",
      "status": "Pending",
      "runtime": "—",
      "memory": "—",
      "detail": "Awaiting execution."
    }
  ]
}
